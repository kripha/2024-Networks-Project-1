#!/usr/bin/env python3.10
from socket import *
import time
import sys

# ./proxy <listen-port> <fake-ip> <server-ip>
listen_port = int(sys.argv[1]) # port your proxy should listen on for accepting connections from the client.
fake_ip = sys.argv[2] # proxy should bind to this IP address for outbound connections to the server.
server_ip = sys.argv[3] # The IP address of the server
server_port = 80

# prepare proxy to be a server
p_serverSocket = socket(AF_INET, SOCK_STREAM)
p_serverSocket.bind(('' , listen_port))

# prepare proxy to be a client 
# p_clientSocket = socket(AF_INET, SOCK_STREAM)
# serverName = 'localhost' is equal to server_ip

while (True):
    # proxy listens and connects with a client
    p_serverSocket.listen(1)
    client_connectionSocket, client_addr = p_serverSocket.accept()
    print("Accepted to client")

    # proxy connects to server when there is a client
    p_clientSocket = socket(AF_INET, SOCK_STREAM)
    p_clientSocket.connect((server_ip, server_port))
    broken = False
    print("Connected to server")

    # for this client
    print("Listen to client")
    while (True):
        # proxy listens for their message
        client_msg = ""
        while (True): # listen to msg until EOS or client breaks
            byte_msg = client_connectionSocket.recv(1)
            if byte_msg.decode() == "": # client breaks
                broken = True
                break
            client_msg += byte_msg.decode()
            
            if byte_msg.decode() == '\r' and client_msg[-2] == '\n': # TODO: determine what EOS
                byte_msg = client_connectionSocket.recv(1) # add in last char to client msg
                client_msg += byte_msg.decode() 
                #print(repr(client_msg))
                break
        
        if broken: # find another client to connect with
            client_connectionSocket.close()
            p_clientSocket.close() # close connection with server
            break
    
        # client_words = client_msg.split(" ")
        # content_len_idx = client_words.index("Content-Length:") + 1
        # content_len = int(client_words[content_len_idx].replace("\r\n", ""))
        # print(f"content_len is {content_len}")

        # proxy send message to server
        p_clientSocket.send(client_msg.encode()) # sends client msg to server
        print("Sent the following to server: ")
        print(client_msg)

        # proxy listens to server
        server_msg = ""
        print("Listen to server")
        while (True): # go through server header
            byte_msg = p_clientSocket.recv(1)
            if byte_msg.decode('utf-16') == "": # TODO: server breaks
                broken = True
                break
            server_msg += byte_msg.decode()
            if byte_msg.decode() == '\r' and client_msg[-2] == '\n':
                byte_msg = p_clientSocket.recv(1) # add in last char to server msg
                server_msg += byte_msg.decode()
                break

        if broken: # find another client to connect with
            client_connectionSocket.close() # close connection with client
            p_clientSocket.close() # close connection with server
            break
            
        # get content length from server headers
        print(f"server response headers: {server_msg}")
        server_words = server_msg.replace("\r\n", "").split(" ")
        content_len_idx = server_words.index("Content-Length:") + 1
        content_len = int(server_words[content_len_idx])
        print(f"content_len is {content_len}")

        # get the body of http response
        for i in range(content_len//2048): # get batches of 2048 bytes
            server_msg += p_clientSocket.recv(2048).decode()
        server_msg += p_clientSocket.recv(content_len % 2048).decode() # get remaining bytes of msg

        # proxy send server_msg to client
        client_connectionSocket.send(server_msg.encode())
        print("Sent the following to client: ")
        print(server_msg)



serverSocket.close()