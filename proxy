#!/usr/bin/env python3.10
from socket import *
import time
import sys
import threading


# ./proxy <logfile> <listen-port> <fake-ip> <server-ip>
logfile_name = sys.argv[1] 
listen_port = int(sys.argv[2]) # port your proxy should listen on for accepting connections from the client.
fake_ip = sys.argv[3] # proxy should bind to this IP address for outbound connections to the server.
server_ip = sys.argv[4] # The IP address of the server
server_port = 80

#TODO: main separate throughput estimates for each <client IP, server IP> pair
#TODO: initialize t_curr to lowest available bitrate for that <client, server> pair
def throughput_calc(start_time, end_time, chunk_size, t_curr, alpha):
    t_new = chunk_size/(end_time-start_time)
    t_curr = alpha*t_new + (1-alpha)*t_curr

def choose_bitrate(t_curr, available_bitrates):
    #TODO: t_curr => 1.5*bitrate
    #TODO: get bitrates are available for a given video by parsing manifest file
    pass

def proxy_handles_client(client_connectionSocket, p_clientSocket):
    broken = False
    f = open(logfile_name, "a")
    available_bitrates = []
    while (True):
        client_msg = ""
        #TODO: fetch BigBuckBunny_6s.mpd and get list of available bitrates
        while (True): # listen to client msg until EOS or client breaks
            byte_msg = client_connectionSocket.recv(1) # could do recv(2048) but with the loop, you are overshooting and thus youre just hanging in the loop
            if byte_msg.decode() == "": # client breaks
                broken = True
                break
            client_msg += byte_msg.decode()
            
            if byte_msg.decode() == '\r' and client_msg[-2] == '\n': 
                byte_msg = client_connectionSocket.recv(1) # add in last char to client msg
                client_msg += byte_msg.decode() 
                break
        
        if broken: 
            client_connectionSocket.close()
            p_clientSocket.close() 
            break

        # proxy send message to server
        #TODO: change HTTP request based on selected bitrate
        #print("DEBUG: client sent:\n",client_msg)
        client_words = client_msg.split(" ")
        chunk_name = client_words[1]
        if "BigBuckBunny_6s_nolist.mpd" in chunk_name:
            client_words[1] = "/BigBuckBunny_6s.mpd"
            client_msg = " ".join(client_words)
            get_mpd = True
        else:
            get_mpd = False
        p_clientSocket.send(client_msg.encode()) # sends client msg to server
        

        # proxy listens to server
        server_msg = ""
        start_time = time.time()
        while (True): 
            # check if we reached the end of header
            if len(server_msg) >= 4 and server_msg[-4:] == "\r\n\r\n":
                break 
            byte_msg = p_clientSocket.recv(1)
            if not byte_msg:
                broken = True
                break
            server_msg += byte_msg.decode()
            if byte_msg.decode() == '\r' and client_msg[-2] == '\n':
                byte_msg = p_clientSocket.recv(1) # add in last char to server msg
                server_msg += byte_msg.decode()
                break

        if broken: # close connections
            client_connectionSocket.close()
            p_clientSocket.close() 
            break
            
        # get content length from server headers
        server_words = server_msg.replace(" ", "").split("\r\n")
        for word in server_words:
            if "Content-Length" in word:
                content_len = int(word.split(":")[-1])

        # get the body of http response 
        body_msg = b""
        while(len(body_msg) != content_len):
            if not byte_msg:
                broken = True
                break
            byte_msg = p_clientSocket.recv(2048)
            body_msg += byte_msg 

        if broken: # close connections
            client_connectionSocket.close()
            p_clientSocket.close()
            break

        if get_mpd:
            # update the available bitrates
            print("DEBUG get_mpd body msg: ", body_msg.decode()) # DEBUG
        #TODO: log <time> <duration> <tput> <avg-tput> <chunk-bitrate> <server-ip> <chunkname>
        f.write(f"{time.time()} {time.time()-start_time} {server_ip} {chunk_name} {content_len}\n")
        f.flush()

        # proxy send server_msg to client
        client_connectionSocket.send(server_msg.encode())
        client_connectionSocket.send(body_msg)

    f.close()

# prepare proxy to be a server
p_serverSocket = socket(AF_INET, SOCK_STREAM)
p_serverSocket.bind(('' , listen_port))
p_serverSocket.listen(0)
while (True):
    # proxy listens and connects with a client
    client_connectionSocket, client_addr = p_serverSocket.accept()
    # proxy connects to server
    p_clientSocket = socket(AF_INET, SOCK_STREAM)
    p_clientSocket.connect((server_ip, server_port))

    #print("Accepted to client")
    t1 = threading.Thread(target=proxy_handles_client, args=(client_connectionSocket, p_clientSocket))
    t1.start()
    


#serverSocket.close()
