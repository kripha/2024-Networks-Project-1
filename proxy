#!/usr/bin/env python3.10
from socket import *
import time
import sys
import threading
import re


#TODO: ./proxy <topo-dir> <log> <alpha> <listen-port> <fake-ip> <dns-server-port>
# but for now just do localhost

logfile_name = sys.argv[2] 
alpha = sys.argv[3] 
listen_port = int(sys.argv[4]) # port your proxy should listen on for accepting connections from the client.
fake_ip = sys.argv[5] # proxy should bind to this IP address for outbound connections to the server.
server_port = sys.argv[6]
server_ip = "3.0.0.1" # TODO: use dns to find server ip
server_port = 80

throughputs = {} # holds the t_curr for each client/server pair

def calc_throughput(start_time, end_time, chunk_size, t_curr, alpha):
    t_new = (chunk_size*8)/(end_time-start_time)
    t_curr = alpha*t_new + (1-alpha)*t_curr
    return t_new, t_curr

def choose_bitrate(t_curr, available_bitrates):
    for b in available_bitrates[::-1]: # start with the highest available
        if t_curr >= 1.5*b:
            return b
    return available_bitrates[0]

def proxy_handles_client(client_connectionSocket, p_clientSocket, client_addr):
    broken = False
    f = open(logfile_name, "a")
    available_bitrates = []
    bitrate = 0
    t_curr = 0
    while (True):
        client_msg = ""
        start_time = time.time()
        while (True): # listen to client msg until EOS or client breaks
            byte_msg = client_connectionSocket.recv(1) # could do recv(2048) but with the loop, you are overshooting and thus youre just hanging in the loop
            if byte_msg.decode() == "": # client breaks
                broken = True
                break
            client_msg += byte_msg.decode()
            
            if byte_msg.decode() == '\r' and client_msg[-2] == '\n': 
                byte_msg = client_connectionSocket.recv(1) # add in last char to client msg
                client_msg += byte_msg.decode() 
                break
        
        if broken: 
            client_connectionSocket.close()
            p_clientSocket.close() 
            break

        # proxy send message to server
        client_words = client_msg.split(" ")
        chunk_name = client_words[1]
        if "BigBuckBunny_6s_nolist.mpd" in chunk_name:
            client_words[1] = "/BigBuckBunny_6s.mpd"
            client_msg = " ".join(client_words)
            get_mpd = True

        else: # modify video request
            get_mpd = False
            t_curr = throughputs[(client_addr, server_ip)]
            bitrate = choose_bitrate(t_curr, available_bitrates)
            bitrate = str(bitrate)
            # /path/to/video/bunny_<bitrate_label>bps/BigBuckBunny_6s<num>
            client_words[1] = f"/path/to/video/bunny_{bitrate}bps/BigBuckBunny_6s{chunk_name[-5]}" # note: there is .m4s at the end from last stage?
            client_msg = " ".join(client_words)

        p_clientSocket.send(client_msg.encode()) # sends client msg to server
        

        # proxy listens to server
        server_msg = ""
        download_start = time.time()
        while (True): 
            # check if we reached the end of header
            if len(server_msg) >= 4 and server_msg[-4:] == "\r\n\r\n":
                break 
            byte_msg = p_clientSocket.recv(1)
            if not byte_msg:
                broken = True
                break
            server_msg += byte_msg.decode()
            if byte_msg.decode() == '\r' and client_msg[-2] == '\n':
                byte_msg = p_clientSocket.recv(1) # add in last char to server msg
                server_msg += byte_msg.decode()
                break

        if broken: # close connections
            client_connectionSocket.close()
            p_clientSocket.close() 
            break
            
        # get content length from server headers
        server_words = server_msg.replace(" ", "").split("\r\n")
        for word in server_words:
            if "Content-Length" in word:
                content_len = int(word.split(":")[-1])

        # get the body of http response 
        body_msg = b""
        while(len(body_msg) != content_len):
            if not byte_msg:
                broken = True
                break
            byte_msg = p_clientSocket.recv(2048)
            body_msg += byte_msg 
        end_time = time.time()
        if broken: # close connections
            client_connectionSocket.close()
            p_clientSocket.close()
            break

        if get_mpd:
            # get available bitrates and initialize t_curr
            for word in body_msg.decode().split(" "):
                if "bandwidth=" in word:
                    word.replace("\"", "")
                    available_bitrates.append(int(word.split("="[-1])))
            available_bitrates = sorted(available_bitrates)
            if (client_addr, server_ip) in throughputs.keys():
                t_curr = throughputs[(client_addr, server_ip)]
            else:
                t_curr = available_bitrates[0]
                throughputs[(client_addr, server_ip)] = t_curr
        else: # update t_curr
            t_new, t_curr = calc_throughput(start_time, end_time, content_len, t_curr, alpha)
            throughputs[(client_addr, server_ip)] = t_curr # update dict


        #TODO: log <time> <duration> <tput> <avg-tput> <chunk-bitrate> <server-ip> <chunkname>
        f.write(f"{time.time()} {time.time()-download_start} {t_new/1000} {t_curr/1000} {bitrate} {server_ip} {chunk_name}\n")
        f.flush()

        # proxy send server_msg to client
        client_connectionSocket.send(server_msg.encode())
        client_connectionSocket.send(body_msg)

    f.close()

# prepare proxy to be a server
p_serverSocket = socket(AF_INET, SOCK_STREAM)
p_serverSocket.bind(('' , listen_port))
p_serverSocket.listen(0)
while (True):
    # proxy listens and connects with a client
    client_connectionSocket, client_addr = p_serverSocket.accept()
    # proxy connects to server
    p_clientSocket = socket(AF_INET, SOCK_STREAM)
    p_clientSocket.connect((server_ip, server_port))

    #print("Accepted to client")
    t1 = threading.Thread(target=proxy_handles_client, args=(client_connectionSocket, p_clientSocket, client_addr))
    t1.start()
    


#serverSocket.close()
