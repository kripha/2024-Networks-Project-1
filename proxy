#!/usr/bin/env python3.10
from socket import *
import time
import sys
import threading


# ./proxy <logfile> <listen-port> <fake-ip> <server-ip>
logfile_name = sys.argv[1] 
listen_port = int(sys.argv[2]) # port your proxy should listen on for accepting connections from the client.
fake_ip = sys.argv[3] # proxy should bind to this IP address for outbound connections to the server.
server_ip = sys.argv[4] # The IP address of the server
server_port = 80

# prepare proxy to be a client 
# p_clientSocket = socket(AF_INET, SOCK_STREAM)
# serverName = 'localhost' is equal to server_ip

def proxy_handles_client(client_connectionSocket, p_clientSocket):
    print(f"{threading.current_thread().name} is doing this")
    # # proxy connects to server
    # p_clientSocket = socket(AF_INET, SOCK_STREAM)
    # p_clientSocket.connect((server_ip, server_port))
    broken = False

    # for this client
    f = open(logfile_name, "a")
    while (True):
        # proxy listens for their message
        client_msg = ""
        print("Listen to client")
        while (True): # listen to msg until EOS or client breaks
            byte_msg = client_connectionSocket.recv(2048)
            if byte_msg.decode() == "": # client breaks
                broken = True
                break
            client_msg += byte_msg.decode()
            
            if byte_msg.decode() == '\r' and client_msg[-2] == '\n': 
                byte_msg = client_connectionSocket.recv(1) # add in last char to client msg
                client_msg += byte_msg.decode() 
                break
        
        if broken: # find another client to connect with
            client_connectionSocket.close()
            p_clientSocket.close() # close connection with server
            break

        # proxy send message to server
        p_clientSocket.send(client_msg.encode()) # sends client msg to server
        print("Sent the following to server: ")
        print(client_msg.split(" ")[1])
        chunk_name = client_msg.split(" ")[1]

        # proxy listens to server
        server_msg = ""
        print("Listen to server")
        start_time = time.time()
        while (True): 
            # check if we reached the end of header
            if len(server_msg) >= 4 and server_msg[-4:] == "\r\n\r\n":
                break 
            byte_msg = p_clientSocket.recv(1)
            if not byte_msg:
                broken = True
                break
            server_msg += byte_msg.decode()
            if byte_msg.decode() == '\r' and client_msg[-2] == '\n':
                byte_msg = p_clientSocket.recv(1) # add in last char to server msg
                server_msg += byte_msg.decode()
                break

        if broken: # close connections
            client_connectionSocket.close()
            p_clientSocket.close() 
            break
            
        # get content length from server headers
        print(f"server response headers: {server_msg}")
        server_words = server_msg.replace(" ", "").split("\r\n")
        print(server_words)
        for word in server_words:
            if "Content-Length" in word:
                content_len = int(word.split(":")[-1])

        # get the body of http response 
        body_msg = b""
        while(len(body_msg) != content_len):
            if not byte_msg:
                broken = True
                break
            byte_msg = p_clientSocket.recv(2048)
            body_msg += byte_msg 

        if broken: # close connections
            client_connectionSocket.close()
            p_clientSocket.close()
            break

        # log 
        #logger.info(f"{time.time()} {time.time()-start_time} {server_ip} {chunk_name} {content_len}\n")

        f.write(f"{time.time()} {time.time()-start_time} {server_ip} {chunk_name} {content_len}\n")
        f.flush()

        # proxy send server_msg to client
        client_connectionSocket.send(server_msg.encode())
        client_connectionSocket.send(body_msg)
        print("Sent response to client ")

    f.close()
    print(f"{threading.current_thread().name} is done")

# prepare proxy to be a server
p_serverSocket = socket(AF_INET, SOCK_STREAM)
p_serverSocket.bind(('' , listen_port))
p_serverSocket.listen(0)
while (True):
    # proxy listens and connects with a client
    client_connectionSocket, client_addr = p_serverSocket.accept()
    # proxy connects to server
    p_clientSocket = socket(AF_INET, SOCK_STREAM)
    p_clientSocket.connect((server_ip, server_port))

    print("Accepted to client")
    t1 = threading.Thread(target=proxy_handles_client, args=(p_serverSocket.accept()[0], p_clientSocket))
    t1.start()
    break


#serverSocket.close()
